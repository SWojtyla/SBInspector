@page "/"
@using SBInspector.Shared.Core.Interfaces
@using SBInspector.Shared.Core.Domain
@using SBInspector.Shared.Application.Services
@using SBInspector.Shared.Presentation.Components.UI
@using System.Text.Json
@using Microsoft.JSInterop
@using MudBlazor
@inject SBInspector.Shared.Core.Interfaces.IServiceBusService ServiceBusService
@inject IFileExportService FileExportService
@inject ConnectionStateService ConnectionState
@inject IDialogService DialogService
@implements IDisposable

<PageTitle>Service Bus Inspector</PageTitle>

<MudContainer MaxWidth="MaxWidth.ExtraExtraLarge" Class="mt-4">
    <MudStack Row="true" AlignItems="AlignItems.Center" Spacing="2" Class="mb-4">
        <MudIcon Icon="@Icons.Material.Filled.ElectricalServices" Size="Size.Large" Color="Color.Primary" />
        <MudText Typo="Typo.h4">@GetPageTitle()</MudText>
    </MudStack>

    @if (!ServiceBusService.IsConnected)
    {
        <ConnectionForm 
            @bind-ConnectionString="@connectionString"
            @bind-ErrorMessage="@errorMessage"
            @bind-IsConnecting="@isConnecting"
            OnConnected="@HandleConnected" />
    }
    else
    {
        <MudStack Row="true" Class="mb-3">
            <MudButton Variant="Variant.Filled" Color="Color.Error" OnClick="Disconnect" StartIcon="@Icons.Material.Filled.PowerOff">Disconnect</MudButton>
        </MudStack>

        <MudGrid>
            <MudItem xs="12" md="3">
                <EntityTreeView 
                    Queues="@queues"
                    Topics="@topics"
                    TopicSubscriptions="@topicSubscriptions"
                    LoadingTopics="@loadingTopics"
                    IsLoading="@isLoadingEntities"
                    SelectedEntityType="@selectedEntityType"
                    SelectedEntityName="@selectedEntityName"
                    OnQueueSelected="@HandleQueueSelected"
                    OnTopicSelected="@HandleTopicSelected"
                    OnSubscriptionSelected="@HandleSubscriptionSelected"
                    OnLoadSubscriptions="@LoadSubscriptionsForTopic"
                    OnRefresh="@HandleRefreshEntities" />
            </MudItem>
            <MudItem xs="12" md="9">
                @if (!string.IsNullOrEmpty(selectedEntity))
                {
                    <MessagesPanel 
                        EntityName="@selectedEntity"
                        MessageType="@selectedMessageType"
                        Messages="@messages"
                        IsLoading="@isLoadingMessages"
                        @bind-Filters="@messageFilters"
                        @bind-SortColumn="@messageSortColumn"
                        @bind-SortAscending="@messageSortAscending"
                        @bind-PageSize="@pageSize"
                        HasMoreMessages="@hasMoreMessages"
                        IsLoadingMore="@isLoadingMoreMessages"
                        OnClose="@CloseMessages"
                        OnExportMessage="@HandleExportSingleMessage"
                        OnDeleteMessage="@HandleDeleteMessage"
                        OnRequeueMessage="@HandleRequeueMessage"
                        OnMoveToDeadLetterMessage="@HandleMoveToDeadLetterMessage"
                        OnRescheduleMessage="@HandleRescheduleMessage"
                        OnSendNew="@HandleSendNewMessage"
                        OnPurge="@HandlePurgeMessages"
                        OnDeleteFiltered="@HandleDeleteFilteredMessages"
                        OnExportFiltered="@HandleExportFilteredMessages"
                        OnLoadMore="@LoadMoreMessages"
                        OnRefresh="@HandleRefreshMessages" />
                }
                else
                {
                    <EntityDetailsPanel 
                        EntityType="@selectedEntityType"
                        QueueInfo="@selectedQueueInfo"
                        TopicInfo="@selectedTopicInfo"
                        SubscriptionInfo="@selectedSubscriptionInfo"
                        TopicName="@selectedTopicForSubscription"
                        OnViewMessages="@HandleViewMessagesFromDetails"
                        OnToggleStatus="@HandleToggleStatusFromDetails" />
                }
            </MudItem>
        </MudGrid>

        @foreach (var operation in activeOperations.Values)
        {
            var operationId = operation.OperationId;
            <BackgroundOperationPanel
                IsVisible="true"
                Title="@(operation.IsDeleteFiltered ? "Deleting Filtered Messages" : "Purging Messages")"
                Message="@operation.ProgressMessage"
                Progress="@operation.Progress"
                OnCancel="@(() => CancelPurgeOperation(operationId))" />
        }

        <OperationLoadingOverlay 
            IsVisible="@isOperationInProgress"
            Title="@operationLoadingTitle"
            Message="@operationLoadingMessage" />

        @if (!string.IsNullOrEmpty(successMessage))
        {
            <MudAlert Severity="Severity.Success" Variant="Variant.Filled" Icon="@Icons.Material.Filled.CheckCircle" 
                      CloseIconClicked="@(() => successMessage = string.Empty)" Class="position-fixed top-0 start-50 translate-middle-x mt-3" Style="z-index: 9999; min-width: 300px;">
                @successMessage
            </MudAlert>
        }

        @if (!string.IsNullOrEmpty(operationErrorMessage))
        {
            <MudAlert Severity="Severity.Error" Variant="Variant.Filled" Icon="@Icons.Material.Filled.Error" 
                      CloseIconClicked="@(() => operationErrorMessage = string.Empty)" Class="position-fixed top-0 start-50 translate-middle-x mt-3" Style="z-index: 9999; min-width: 300px;">
                @operationErrorMessage
            </MudAlert>
        }
    }
</MudContainer>

@code {
    private string connectionString = string.Empty;
    private string errorMessage = string.Empty;
    private bool isConnecting = false;
    private bool isLoadingEntities = false;
    private bool isLoadingMessages = false;
    
    private List<EntityInfo> queues = new();
    private List<EntityInfo> topics = new();
    private List<MessageInfo> messages = new();
    private Dictionary<string, List<SubscriptionInfo>> topicSubscriptions = new();
    private HashSet<string> loadingTopics = new();
    
    // Cancellation token for connection switching
    private CancellationTokenSource? loadEntitiesCts = null;
    
    // Tree selection state
    private string? selectedEntityType = null;
    private string? selectedEntityName = null;
    private EntityInfo? selectedQueueInfo = null;
    private EntityInfo? selectedTopicInfo = null;
    private SubscriptionInfo? selectedSubscriptionInfo = null;
    private string? selectedTopicForSubscription = null;
    
    // Message viewing state
    private string selectedEntity = string.Empty;
    private string selectedMessageType = string.Empty;
    private string selectedTopic = string.Empty;
    private string selectedSubscriptionName = string.Empty;
    
    private List<MessageFilter> messageFilters = new() { new MessageFilter() };
    
    // Pagination state
    private int pageSize = 100;
    private bool hasMoreMessages = false;
    private bool isLoadingMoreMessages = false;

    // Sorting state for messages
    private string messageSortColumn = nameof(MessageInfo.EnqueuedTime);
    private bool messageSortAscending = false;

    private async Task HandleConnected()
    {
        ConnectionState.CurrentConnectionString = connectionString;
        await LoadAllEntitiesAsync();
    }

    protected override async Task OnInitializedAsync()
    {
        // Subscribe to connection state changes
        ConnectionState.OnChange += HandleConnectionStateChanged;
        
        // If already connected (e.g., after page refresh), reload entities
        if (ServiceBusService.IsConnected)
        {
            await LoadAllEntitiesAsync();
        }
    }

    private async void HandleConnectionStateChanged()
    {
        // This is called when connection changes (e.g., switching connections from tree view)
        await InvokeAsync(async () =>
        {
            try
            {
                if (ServiceBusService.IsConnected && !string.IsNullOrEmpty(ConnectionState.CurrentConnectionString))
                {
                    // Connection switched - clear old data and load new entities
                    await ClearAllDataAndReload();
                }
            }
            catch (Exception ex)
            {
                // Handle exceptions during connection switching
                operationErrorMessage = $"Error switching connection: {ex.Message}";
                await Task.Delay(5000);
                operationErrorMessage = string.Empty;
            }
            finally
            {
                StateHasChanged();
            }
        });
    }

    private async Task ClearAllDataAndReload()
    {
        // Cancel any ongoing entity loading operation
        if (loadEntitiesCts != null)
        {
            loadEntitiesCts.Cancel();
            loadEntitiesCts.Dispose();
            loadEntitiesCts = null;
        }
        
        // Show loading state immediately
        isLoadingEntities = true;
        StateHasChanged();
        
        // Clear all existing data
        queues.Clear();
        topics.Clear();
        messages.Clear();
        topicSubscriptions.Clear();
        loadingTopics.Clear();
        selectedEntity = string.Empty;
        selectedTopic = string.Empty;
        selectedEntityType = null;
        selectedEntityName = null;
        selectedQueueInfo = null;
        selectedTopicInfo = null;
        selectedSubscriptionInfo = null;
        selectedTopicForSubscription = null;
        selectedSubscriptionName = string.Empty;
        
        // Reset message viewing state
        messageFilters.Clear();
        messageFilters.Add(new MessageFilter());
        messageSortColumn = nameof(MessageInfo.EnqueuedTime);
        messageSortAscending = false;
        hasMoreMessages = false;
        isLoadingMoreMessages = false;
        
        // Reset operation state
        successMessage = string.Empty;
        operationErrorMessage = string.Empty;
        isOperationInProgress = false;
        isDeleteFiltered = false;
        
        // Cancel and clean up active purge operations
        foreach (var operation in activeOperations.Values)
        {
            try
            {
                operation.CancellationTokenSource?.Cancel();
                operation.CancellationTokenSource?.Dispose();
            }
            catch
            {
                // Ignore disposal errors
            }
        }
        activeOperations.Clear();
        
        // Load new entities with cancellation support
        await LoadAllEntitiesAsync();
    }

    public void Dispose()
    {
        ConnectionState.OnChange -= HandleConnectionStateChanged;
        
        // Clean up cancellation token
        if (loadEntitiesCts != null)
        {
            loadEntitiesCts.Cancel();
            loadEntitiesCts.Dispose();
            loadEntitiesCts = null;
        }
        
        // Clean up active purge operations
        foreach (var operation in activeOperations.Values)
        {
            try
            {
                operation.CancellationTokenSource?.Cancel();
                operation.CancellationTokenSource?.Dispose();
            }
            catch
            {
                // Ignore disposal errors
            }
        }
        activeOperations.Clear();
    }

    private async Task Disconnect()
    {
        await ServiceBusService.DisconnectAsync();
        ConnectionState.CurrentConnectionString = null;
        queues.Clear();
        topics.Clear();
        messages.Clear();
        topicSubscriptions.Clear();
        loadingTopics.Clear();
        selectedEntity = string.Empty;
        selectedTopic = string.Empty;
        selectedEntityType = null;
        selectedEntityName = null;
        selectedQueueInfo = null;
        selectedTopicInfo = null;
        selectedSubscriptionInfo = null;
        selectedTopicForSubscription = null;
        selectedSubscriptionName = string.Empty;
        
        // Reset message viewing state
        messageFilters.Clear();
        messageFilters.Add(new MessageFilter());
        messageSortColumn = nameof(MessageInfo.EnqueuedTime);
        messageSortAscending = false;
        hasMoreMessages = false;
        isLoadingMoreMessages = false;
        
        // Reset operation state
        successMessage = string.Empty;
        operationErrorMessage = string.Empty;
        isOperationInProgress = false;
        isDeleteFiltered = false;
        
        // Cancel any ongoing purge operations
        try
        {
            foreach (var operation in activeOperations.Values)
            {
                operation.CancellationTokenSource?.Cancel();
                operation.CancellationTokenSource?.Dispose();
            }
            activeOperations.Clear();
        }
        catch (ObjectDisposedException)
        {
            // Token was already disposed, ignore
        }
        catch (AggregateException)
        {
            // Cancellation may throw AggregateException, ignore
        }
    }

    private async Task LoadAllEntitiesAsync()
    {
        // Create a new cancellation token for this operation
        loadEntitiesCts = new CancellationTokenSource();
        var cts = loadEntitiesCts;
        
        isLoadingEntities = true;
        selectedEntity = string.Empty;
        selectedTopic = string.Empty;
        
        try
        {
            // Check if cancelled before starting
            cts.Token.ThrowIfCancellationRequested();
            
            queues = await ServiceBusService.GetQueuesAsync();
            
            // Check if cancelled between operations
            cts.Token.ThrowIfCancellationRequested();
            
            topics = await ServiceBusService.GetTopicsAsync();
        }
        catch (OperationCanceledException)
        {
            // Operation was cancelled (likely due to rapid connection switching)
            // This is expected, just return without setting error
            return;
        }
        catch (Exception ex)
        {
            // Handle other exceptions
            operationErrorMessage = $"Error loading entities: {ex.Message}";
            await Task.Delay(5000);
            operationErrorMessage = string.Empty;
        }
        finally
        {
            // Only clear loading state if this is still the current operation
            if (loadEntitiesCts == cts)
            {
                isLoadingEntities = false;
            }
        }
    }

    private async Task HandleRefreshEntities()
    {
        isLoadingEntities = true;
        
        try
        {
            // Reload all queues and topics
            queues = await ServiceBusService.GetQueuesAsync();
            topics = await ServiceBusService.GetTopicsAsync();
            
            // Reload subscriptions for expanded topics
            var expandedTopicsList = topicSubscriptions.Keys.ToList();
            foreach (var topicName in expandedTopicsList)
            {
                loadingTopics.Add(topicName);
                try
                {
                    var subs = await ServiceBusService.GetSubscriptionsAsync(topicName);
                    topicSubscriptions[topicName] = subs;
                }
                finally
                {
                    loadingTopics.Remove(topicName);
                }
            }
            
            // Update selected entity info if applicable
            if (selectedEntityType == "queue" && !string.IsNullOrEmpty(selectedEntityName))
            {
                selectedQueueInfo = queues.FirstOrDefault(q => q.Name == selectedEntityName);
            }
            else if (selectedEntityType == "topic" && !string.IsNullOrEmpty(selectedEntityName))
            {
                selectedTopicInfo = topics.FirstOrDefault(t => t.Name == selectedEntityName);
            }
            else if (selectedEntityType == "subscription" && !string.IsNullOrEmpty(selectedTopicForSubscription))
            {
                var parts = selectedEntityName?.Split('/');
                if (parts?.Length == 2 && topicSubscriptions.ContainsKey(parts[0]))
                {
                    selectedSubscriptionInfo = topicSubscriptions[parts[0]].FirstOrDefault(s => s.Name == parts[1]);
                }
            }
        }
        finally
        {
            isLoadingEntities = false;
        }
    }

    private void HandleQueueSelected(string queueName)
    {
        selectedEntityType = "queue";
        selectedEntityName = queueName;
        selectedQueueInfo = queues.FirstOrDefault(q => q.Name == queueName);
        selectedTopicInfo = null;
        selectedSubscriptionInfo = null;
        selectedTopicForSubscription = null;
        
        // Clear messages panel
        selectedEntity = string.Empty;
        messages.Clear();
    }

    private void HandleTopicSelected(string topicName)
    {
        selectedEntityType = "topic";
        selectedEntityName = topicName;
        selectedTopicInfo = topics.FirstOrDefault(t => t.Name == topicName);
        selectedQueueInfo = null;
        selectedSubscriptionInfo = null;
        selectedTopicForSubscription = null;
        
        // Clear messages panel
        selectedEntity = string.Empty;
        messages.Clear();
    }

    private void HandleSubscriptionSelected((string TopicName, string SubscriptionName) args)
    {
        selectedEntityType = "subscription";
        selectedEntityName = $"{args.TopicName}/{args.SubscriptionName}";
        selectedTopicForSubscription = args.TopicName;
        
        if (topicSubscriptions.ContainsKey(args.TopicName))
        {
            selectedSubscriptionInfo = topicSubscriptions[args.TopicName].FirstOrDefault(s => s.Name == args.SubscriptionName);
        }
        
        selectedQueueInfo = null;
        selectedTopicInfo = null;
        
        // Clear messages panel
        selectedEntity = string.Empty;
        messages.Clear();
    }

    private async Task LoadSubscriptionsForTopic(string topicName)
    {
        if (topicSubscriptions.ContainsKey(topicName))
        {
            return; // Already loaded
        }

        loadingTopics.Add(topicName);
        
        try
        {
            var subs = await ServiceBusService.GetSubscriptionsAsync(topicName);
            topicSubscriptions[topicName] = subs;
        }
        finally
        {
            loadingTopics.Remove(topicName);
        }
    }

    private async Task HandleViewMessagesFromDetails(string messageType)
    {
        if (selectedEntityType == "queue" && selectedQueueInfo != null)
        {
            await HandleViewQueueMessages((selectedQueueInfo.Name, messageType));
        }
        else if (selectedEntityType == "subscription" && selectedSubscriptionInfo != null && !string.IsNullOrEmpty(selectedTopicForSubscription))
        {
            await HandleViewSubscriptionMessages((selectedTopicForSubscription, selectedSubscriptionInfo.Name, messageType));
        }
    }

    private async Task HandleToggleStatusFromDetails()
    {
        if (selectedEntityType == "queue" && selectedQueueInfo != null)
        {
            await HandleToggleQueueStatus(selectedQueueInfo.Name);
        }
        else if (selectedEntityType == "topic" && selectedTopicInfo != null)
        {
            await HandleToggleTopicStatus(selectedTopicInfo.Name);
        }
        else if (selectedEntityType == "subscription" && selectedSubscriptionInfo != null && !string.IsNullOrEmpty(selectedTopicForSubscription))
        {
            await HandleToggleSubscriptionStatus((selectedTopicForSubscription, selectedSubscriptionInfo.Name));
        }
    }

    private async Task HandleViewQueueMessages((string QueueName, string MessageType) args)
    {
        selectedEntity = args.QueueName;
        selectedMessageType = args.MessageType;
        selectedTopic = string.Empty;
        selectedSubscriptionName = string.Empty;
        isLoadingMessages = true;
        
        try
        {
            messages = await ServiceBusService.GetMessagesAsync(args.QueueName, args.MessageType, pageSize);
            hasMoreMessages = messages.Count == pageSize;
        }
        finally
        {
            isLoadingMessages = false;
        }
    }

    private void CloseMessages()
    {
        selectedEntity = string.Empty;
        selectedMessageType = string.Empty;
        selectedSubscriptionName = string.Empty;
        messages.Clear();
        messageFilters.Clear();
        messageFilters.Add(new MessageFilter());
        hasMoreMessages = false;
    }

    private async Task HandleViewSubscriptionMessages((string TopicName, string SubscriptionName, string MessageType) args)
    {
        selectedEntity = $"{args.TopicName}/{args.SubscriptionName}";
        selectedMessageType = args.MessageType;
        selectedSubscriptionName = args.SubscriptionName;
        selectedTopic = args.TopicName;
        isLoadingMessages = true;
        
        try
        {
            messages = await ServiceBusService.GetSubscriptionMessagesAsync(args.TopicName, args.SubscriptionName, args.MessageType, pageSize);
            hasMoreMessages = messages.Count == pageSize;
        }
        finally
        {
            isLoadingMessages = false;
        }
    }
    
    private async Task LoadMoreMessages()
    {
        if (!hasMoreMessages || isLoadingMoreMessages || messages.Count == 0) return;
        
        isLoadingMoreMessages = true;
        
        try
        {
            // Get the last message's sequence number to continue from the next one
            var lastSequenceNumber = messages.Max(m => m.SequenceNumber) + 1;
            
            List<MessageInfo> newMessages;
            
            // Determine if we're loading from a queue or subscription
            if (!string.IsNullOrEmpty(selectedSubscriptionName))
            {
                // It's a subscription
                newMessages = await ServiceBusService.GetSubscriptionMessagesAsync(
                    selectedTopic, 
                    selectedSubscriptionName, 
                    selectedMessageType, 
                    pageSize, 
                    lastSequenceNumber);
            }
            else
            {
                // It's a queue
                newMessages = await ServiceBusService.GetMessagesAsync(
                    selectedEntity, 
                    selectedMessageType, 
                    pageSize, 
                    lastSequenceNumber);
            }
            
            if (newMessages.Count > 0)
            {
                messages.AddRange(newMessages);
                hasMoreMessages = newMessages.Count == pageSize;
            }
            else
            {
                hasMoreMessages = false;
            }
        }
        finally
        {
            isLoadingMoreMessages = false;
        }
    }

    private async Task HandleRefreshMessages()
    {
        if (string.IsNullOrEmpty(selectedEntity)) return;
        
        isLoadingMessages = true;
        
        try
        {
            if (!string.IsNullOrEmpty(selectedSubscriptionName))
            {
                // It's a subscription
                messages = await ServiceBusService.GetSubscriptionMessagesAsync(
                    selectedTopic, 
                    selectedSubscriptionName, 
                    selectedMessageType, 
                    pageSize);
            }
            else
            {
                // It's a queue
                messages = await ServiceBusService.GetMessagesAsync(
                    selectedEntity, 
                    selectedMessageType, 
                    pageSize);
            }
            
            hasMoreMessages = messages.Count == pageSize;
            
            // Also refresh entity counts
            await RefreshEntityCounts();
        }
        finally
        {
            isLoadingMessages = false;
        }
    }

    // CRUD operation state
    private string successMessage = string.Empty;
    private string operationErrorMessage = string.Empty;
    
    // Operation loading state
    private bool isOperationInProgress = false;
    private string operationLoadingTitle = string.Empty;
    private string operationLoadingMessage = string.Empty;
    
    // Purge operation state - support for multiple concurrent purge operations
    private bool isDeleteFiltered = false; // Flag to differentiate between normal purge and filtered delete
    
    private class PurgeOperation
    {
        public string OperationId { get; set; } = string.Empty;
        public string EntityName { get; set; } = string.Empty;
        public string MessageType { get; set; } = string.Empty;
        public string ProgressMessage { get; set; } = string.Empty;
        public int Progress { get; set; }
        public CancellationTokenSource CancellationTokenSource { get; set; } = new();
        public bool IsDeleteFiltered { get; set; }
    }
    
    private Dictionary<string, PurgeOperation> activeOperations = new Dictionary<string, PurgeOperation>();

    private async Task HandleDeleteMessage(MessageInfo message)
    {
        var parameters = new DialogParameters<ConfirmationModal>
        {
            { x => x.Message, $"Are you sure you want to delete message '{message.MessageId}'? This action cannot be undone." },
            { x => x.ConfirmText, "Delete" },
            { x => x.ConfirmColor, Color.Error },
            { x => x.ConfirmIconClass, "bi-trash" }
        };

        var options = new DialogOptions
        {
            MaxWidth = MaxWidth.Small,
            FullWidth = true,
            CloseButton = true
        };

        var dialog = await DialogService.ShowAsync<ConfirmationModal>(
            "Delete Message",
            parameters,
            options);

        var result = await dialog.Result;

        if (!result.Canceled)
        {
            operationErrorMessage = string.Empty;
            successMessage = string.Empty;

            isOperationInProgress = true;
            operationLoadingTitle = "Deleting Message";
            operationLoadingMessage = "Please wait while the message is being deleted...";

            try
            {
                var msgOptions = MessageOperationOptions.FromMessageInfo(
                    message,
                    selectedEntity,
                    !string.IsNullOrEmpty(selectedSubscriptionName),
                    selectedTopic,
                    selectedSubscriptionName);
                    
                bool success = await ServiceBusService.DeleteMessageAsync(msgOptions);

                if (success)
                {
                    messages.Remove(message);
                    successMessage = "Message deleted successfully.";
                    
                    // Refresh entity counts to update the tree
                    await RefreshEntityCounts();
                    
                    await Task.Delay(3000);
                    successMessage = string.Empty;
                }
                else
                {
                    operationErrorMessage = "Failed to delete message. It may have already been processed.";
                    await Task.Delay(5000);
                    operationErrorMessage = string.Empty;
                }
            }
            catch (Exception ex)
            {
                operationErrorMessage = $"Error deleting message: {ex.Message}";
                await Task.Delay(5000);
                operationErrorMessage = string.Empty;
            }
            finally
            {
                isOperationInProgress = false;
            }
        }
    }

    private async Task HandleRequeueMessage(MessageInfo message)
    {
        var parameters = new DialogParameters<ConfirmationModal>
        {
            { x => x.Message, "Are you sure you want to requeue this message from the dead-letter queue to the active queue?" },
            { x => x.ConfirmText, "Requeue" },
            { x => x.ConfirmColor, Color.Success },
            { x => x.ConfirmIconClass, "bi-check-lg" }
        };

        var options = new DialogOptions
        {
            MaxWidth = MaxWidth.Small,
            FullWidth = true,
            CloseButton = true
        };

        var dialog = await DialogService.ShowAsync<ConfirmationModal>(
            "Requeue Message",
            parameters,
            options);

        var result = await dialog.Result;

        if (!result.Canceled)
        {
            operationErrorMessage = string.Empty;
            successMessage = string.Empty;

            isOperationInProgress = true;
            operationLoadingTitle = "Requeuing Message";
            operationLoadingMessage = "Please wait while the message is being moved back to the active queue...";

            try
            {
                var msgOptions = MessageOperationOptions.FromMessageInfo(
                    message,
                    selectedEntity,
                    !string.IsNullOrEmpty(selectedSubscriptionName),
                    selectedTopic,
                    selectedSubscriptionName);
                    
                bool success = await ServiceBusService.RequeueDeadLetterMessageAsync(msgOptions);

                if (success)
                {
                    messages.Remove(message);
                    successMessage = "Message requeued successfully.";
                    
                    // Refresh entity counts to update the tree
                    await RefreshEntityCounts();
                    
                    await Task.Delay(3000);
                    successMessage = string.Empty;
                }
                else
                {
                    operationErrorMessage = "Failed to requeue message. It may have already been processed.";
                    await Task.Delay(5000);
                    operationErrorMessage = string.Empty;
                }
            }
            catch (Exception ex)
            {
                operationErrorMessage = $"Error requeuing message: {ex.Message}";
                await Task.Delay(5000);
                operationErrorMessage = string.Empty;
            }
            finally
            {
                isOperationInProgress = false;
            }
        }
    }

    private async Task HandleMoveToDeadLetterMessage(MessageInfo message)
    {
        var parameters = new DialogParameters<ConfirmationModal>
        {
            { x => x.Message, "Are you sure you want to move this active message to the dead-letter queue? This action cannot be undone." },
            { x => x.ConfirmText, "Move to Dead-Letter" },
            { x => x.ConfirmColor, Color.Warning },
            { x => x.ConfirmIconClass, "bi-exclamation-triangle" }
        };

        var options = new DialogOptions
        {
            MaxWidth = MaxWidth.Small,
            FullWidth = true,
            CloseButton = true
        };

        var dialog = await DialogService.ShowAsync<ConfirmationModal>(
            "Move to Dead-Letter Queue",
            parameters,
            options);

        var result = await dialog.Result;

        if (!result.Canceled)
        {
            operationErrorMessage = string.Empty;
            successMessage = string.Empty;

            isOperationInProgress = true;
            operationLoadingTitle = "Moving to Dead-Letter";
            operationLoadingMessage = "Please wait while the message is being moved to the dead-letter queue...";

            try
            {
                var msgOptions = MessageOperationOptions.FromMessageInfo(
                    message,
                    selectedEntity,
                    !string.IsNullOrEmpty(selectedSubscriptionName),
                    selectedTopic,
                    selectedSubscriptionName);
                    
                bool success = await ServiceBusService.MoveActiveMessageToDeadLetterAsync(msgOptions);

                if (success)
                {
                    messages.Remove(message);
                    successMessage = "Message moved to dead-letter queue successfully.";
                    
                    // Refresh entity counts to update the tree
                    await RefreshEntityCounts();
                    
                    await Task.Delay(3000);
                    successMessage = string.Empty;
                }
                else
                {
                    operationErrorMessage = "Failed to move message to dead-letter queue. It may have already been processed.";
                    await Task.Delay(5000);
                    operationErrorMessage = string.Empty;
                }
            }
            catch (Exception ex)
            {
                operationErrorMessage = $"Error moving message to dead-letter queue: {ex.Message}";
                await Task.Delay(5000);
                operationErrorMessage = string.Empty;
            }
            finally
            {
                isOperationInProgress = false;
            }
        }
    }

    private async Task HandleRescheduleMessage(MessageInfo message)
    {
        var parameters = new DialogParameters<SendMessageModal>
        {
            { x => x.IsReschedule, true },
            { x => x.ExistingMessage, message }
        };

        var options = new DialogOptions
        {
            MaxWidth = MaxWidth.Large,
            FullWidth = true,
            CloseButton = true
        };

        var dialog = await DialogService.ShowAsync<SendMessageModal>(
            "Reschedule Message",
            parameters,
            options);

        var result = await dialog.Result;

        if (!result.Canceled && result.Data is SendMessageModal.MessageData data)
        {
            operationErrorMessage = string.Empty;
            successMessage = string.Empty;

            try
            {
                // Reschedule existing message
                if (!data.ScheduledTime.HasValue)
                {
                    operationErrorMessage = "Scheduled time is required for rescheduling.";
                    return;
                }

                var msgOptions = MessageOperationOptions.FromMessageInfo(
                    message,
                    selectedEntity,
                    !string.IsNullOrEmpty(selectedSubscriptionName),
                    selectedTopic,
                    selectedSubscriptionName);
                    
                bool success = await ServiceBusService.RescheduleMessageAsync(msgOptions, data.ScheduledTime.Value);

                if (success)
                {
                    messages.Remove(message);
                    successMessage = $"Message rescheduled for {data.ScheduledTime.Value:yyyy-MM-dd HH:mm:ss}.";
                    
                    // Refresh entity counts to update the sidebar
                    await RefreshEntityCounts();
                }
                else
                {
                    operationErrorMessage = "Failed to reschedule message. It may have already been processed.";
                }

                await Task.Delay(3000);
                successMessage = string.Empty;
                operationErrorMessage = string.Empty;
            }
            catch (Exception ex)
            {
                operationErrorMessage = $"Error: {ex.Message}";
                await Task.Delay(5000);
                operationErrorMessage = string.Empty;
            }
        }
    }

    private async Task HandleSendNewMessage()
    {
        var parameters = new DialogParameters<SendMessageModal>
        {
            { x => x.IsReschedule, false },
            { x => x.ExistingMessage, null }
        };

        var options = new DialogOptions
        {
            MaxWidth = MaxWidth.Large,
            FullWidth = true,
            CloseButton = true
        };

        var dialog = await DialogService.ShowAsync<SendMessageModal>(
            "Send New Message",
            parameters,
            options);

        var result = await dialog.Result;

        if (!result.Canceled && result.Data is SendMessageModal.MessageData data)
        {
            operationErrorMessage = string.Empty;
            successMessage = string.Empty;

            try
            {
                bool success;

                // Send new message
                var entityToSendTo = !string.IsNullOrEmpty(selectedSubscriptionName) ? selectedTopic : selectedEntity;
                
                if (data.SendToDeadLetter)
                {
                    // Send to dead-letter queue
                    success = await ServiceBusService.SendMessageToDeadLetterQueueAsync(
                        entityToSendTo,
                        data.Body,
                        data.Subject,
                        data.ContentType,
                        data.Properties,
                        isSubscription: !string.IsNullOrEmpty(selectedSubscriptionName),
                        topicName: selectedTopic,
                        subscriptionName: selectedSubscriptionName);
                }
                else
                {
                    // Send to regular queue/topic
                    success = await ServiceBusService.SendMessageAsync(
                        entityToSendTo,
                        data.Body,
                        data.Subject,
                        data.ContentType,
                        data.Properties,
                        data.ScheduledTime);
                }

                if (success)
                {
                    if (data.SendToDeadLetter)
                    {
                        successMessage = "Message sent to dead-letter queue successfully.";
                    }
                    else if (data.ScheduledTime.HasValue)
                    {
                        successMessage = $"Message scheduled for {data.ScheduledTime.Value:yyyy-MM-dd HH:mm:ss}.";
                    }
                    else
                    {
                        successMessage = "Message sent successfully.";
                    }
                    
                    // Refresh the message list to show the new message
                    await HandleRefreshMessages();
                }
                else
                {
                    operationErrorMessage = data.SendToDeadLetter 
                        ? "Failed to send message to dead-letter queue." 
                        : "Failed to send message.";
                }

                await Task.Delay(3000);
                successMessage = string.Empty;
                operationErrorMessage = string.Empty;
            }
            catch (Exception ex)
            {
                operationErrorMessage = $"Error: {ex.Message}";
                await Task.Delay(5000);
                operationErrorMessage = string.Empty;
            }
        }
    }

    private async Task HandlePurgeMessages()
    {
        var messageTypeDisplay = selectedMessageType switch
        {
            "Active" => "active",
            "Scheduled" => "scheduled",
            "DeadLetter" => "dead-letter",
            _ => selectedMessageType.ToLower()
        };

        var parameters = new DialogParameters<ConfirmationModal>
        {
            { x => x.Message, $"Are you sure you want to PURGE ALL {messageTypeDisplay} messages from '{selectedEntity}'? This will permanently delete ALL messages and cannot be undone. Type 'PURGE' to confirm." },
            { x => x.ConfirmText, "Purge All" },
            { x => x.ConfirmColor, Color.Error },
            { x => x.ConfirmIconClass, "bi-trash-fill" }
        };

        var options = new DialogOptions
        {
            MaxWidth = MaxWidth.Small,
            FullWidth = true,
            CloseButton = true
        };

        var dialog = await DialogService.ShowAsync<ConfirmationModal>(
            $"Purge All {messageTypeDisplay} Messages",
            parameters,
            options);

        var result = await dialog.Result;

        if (!result.Canceled)
        {
            await ExecutePurgeOperation(false);
        }
    }

    private async Task ExecutePurgeOperation(bool isFiltered)
    {
        operationErrorMessage = string.Empty;
        successMessage = string.Empty;

        // Create a unique operation ID for this purge operation
        var operationId = $"{selectedEntity}_{selectedMessageType}_{(isFiltered ? "filtered_" : "")}{Guid.NewGuid()}";
        
        var messageTypeDisplay = selectedMessageType switch
        {
            "Active" => "active",
            "Scheduled" => "scheduled",
            "DeadLetter" => "dead-letter",
            _ => selectedMessageType.ToLower()
        };
        
        var operation = new PurgeOperation
        {
            OperationId = operationId,
            EntityName = selectedEntity,
            MessageType = selectedMessageType,
            ProgressMessage = isFiltered 
                ? $"Deleting filtered {messageTypeDisplay} messages from '{selectedEntity}'..."
                : $"Deleting {messageTypeDisplay} messages from '{selectedEntity}'...",
            Progress = 0,
            CancellationTokenSource = new CancellationTokenSource(),
            IsDeleteFiltered = isFiltered
        };
        
        activeOperations[operationId] = operation;
        
        StateHasChanged();

        // Capture current entity context for the background task
        var capturedEntity = selectedEntity;
        var capturedMessageType = selectedMessageType;
        var capturedSubscriptionName = selectedSubscriptionName;
        var capturedTopic = selectedTopic;
        var capturedFilters = isFiltered ? messageFilters.ToList() : null;

        // Run purge in background
        _ = Task.Run(async () =>
        {
            try
            {
                var progress = new Progress<int>(count =>
                {
                    if (activeOperations.TryGetValue(operationId, out var op))
                    {
                        op.Progress = count;
                    }
                    InvokeAsync(StateHasChanged);
                });

                int deletedCount;

                if (isFiltered && capturedFilters != null)
                {
                    // Filtered delete
                    if (!string.IsNullOrEmpty(capturedSubscriptionName))
                    {
                        deletedCount = await ServiceBusService.DeleteFilteredMessagesAsync(
                            capturedEntity,
                            capturedMessageType,
                            capturedFilters,
                            isSubscription: true,
                            topicName: capturedTopic,
                            subscriptionName: capturedSubscriptionName,
                            cancellationToken: operation.CancellationTokenSource.Token,
                            progress: progress);
                    }
                    else
                    {
                        deletedCount = await ServiceBusService.DeleteFilteredMessagesAsync(
                            capturedEntity,
                            capturedMessageType,
                            capturedFilters,
                            cancellationToken: operation.CancellationTokenSource.Token,
                            progress: progress);
                    }
                }
                else
                {
                    // Regular purge
                    if (!string.IsNullOrEmpty(capturedSubscriptionName))
                    {
                        // It's a subscription
                        deletedCount = await ServiceBusService.PurgeMessagesAsync(
                            capturedEntity,
                            capturedMessageType,
                            isSubscription: true,
                            topicName: capturedTopic,
                            subscriptionName: capturedSubscriptionName,
                            cancellationToken: operation.CancellationTokenSource.Token,
                            progress: progress);
                    }
                    else
                    {
                        // It's a queue
                        deletedCount = await ServiceBusService.PurgeMessagesAsync(
                            capturedEntity,
                            capturedMessageType,
                            cancellationToken: operation.CancellationTokenSource.Token,
                            progress: progress);
                    }
                }

                await InvokeAsync(async () =>
                {
                    // Remove from active operations
                    activeOperations.Remove(operationId);
                    
                    // Null-safe check for cancellation token
                    bool wasCancelled = operation.CancellationTokenSource?.Token.IsCancellationRequested ?? false;
                    
                    if (wasCancelled)
                    {
                        successMessage = isFiltered 
                            ? $"Delete cancelled. Deleted {deletedCount} message(s) before cancellation."
                            : $"Purge cancelled. Deleted {deletedCount} message(s) before cancellation.";
                    }
                    else if (deletedCount > 0)
                    {
                        // Only clear messages if this purge was for the currently selected entity
                        if (capturedEntity == selectedEntity && capturedMessageType == selectedMessageType)
                        {
                            if (isFiltered)
                            {
                                // Refresh to show remaining messages after filtered delete
                                await HandleRefreshMessages();
                            }
                            else
                            {
                                messages.Clear();
                                hasMoreMessages = false;
                            }
                        }
                        
                        // Refresh entity counts to update the tree
                        await RefreshEntityCounts();
                        
                        successMessage = isFiltered
                            ? $"Successfully deleted {deletedCount} filtered message(s) from {capturedEntity}."
                            : $"Successfully purged {deletedCount} message(s) from {capturedEntity}.";
                    }
                    else
                    {
                        operationErrorMessage = $"No messages were found to {(isFiltered ? "delete" : "purge")} in {capturedEntity}.";
                    }
                    
                    StateHasChanged();
                    
                    await Task.Delay(3000);
                    successMessage = string.Empty;
                    operationErrorMessage = string.Empty;
                    StateHasChanged();
                });
            }
            catch (OperationCanceledException)
            {
                await InvokeAsync(() =>
                {
                    activeOperations.Remove(operationId);
                    successMessage = isFiltered
                        ? $"Delete cancelled. Deleted {operation.Progress} message(s) before cancellation."
                        : $"Purge cancelled. Deleted {operation.Progress} message(s) before cancellation.";
                    StateHasChanged();
                });
                
                await Task.Delay(3000);
                await InvokeAsync(() =>
                {
                    successMessage = string.Empty;
                    StateHasChanged();
                });
            }
            catch (Exception ex)
            {
                await InvokeAsync(() =>
                {
                    activeOperations.Remove(operationId);
                    operationErrorMessage = $"Error {(isFiltered ? "deleting" : "purging")} messages from {capturedEntity}: {ex.Message}";
                    StateHasChanged();
                });
                
                await Task.Delay(5000);
                await InvokeAsync(() =>
                {
                    operationErrorMessage = string.Empty;
                    StateHasChanged();
                });
            }
            finally
            {
                operation.CancellationTokenSource?.Dispose();
            }
        });
    }

    private void CancelPurgeOperation(string operationId)
    {
        if (activeOperations.TryGetValue(operationId, out var operation))
        {
            operation.CancellationTokenSource?.Cancel();
        }
    }

    private async Task HandleDeleteFilteredMessages()
    {
        // Check if there are any active filters
        var hasActiveFilters = messageFilters.Any(f => !string.IsNullOrWhiteSpace(f.AttributeName) || !string.IsNullOrWhiteSpace(f.AttributeValue));
        
        if (!hasActiveFilters)
        {
            operationErrorMessage = "No filters applied. Use 'Purge All' to delete all messages, or apply filters first.";
            _ = Task.Run(async () =>
            {
                await Task.Delay(5000);
                await InvokeAsync(() =>
                {
                    operationErrorMessage = string.Empty;
                    StateHasChanged();
                });
            });
            return;
        }

        var messageTypeDisplay = selectedMessageType switch
        {
            "Active" => "active",
            "Scheduled" => "scheduled",
            "DeadLetter" => "dead-letter",
            _ => selectedMessageType.ToLower()
        };

        var parameters = new DialogParameters<ConfirmationModal>
        {
            { x => x.Message, $"Are you sure you want to DELETE ALL {messageTypeDisplay} messages from '{selectedEntity}' that match the current filters? This will permanently delete matching messages and cannot be undone. Type 'DELETE' to confirm." },
            { x => x.ConfirmText, "Delete Filtered" },
            { x => x.ConfirmColor, Color.Error },
            { x => x.ConfirmIconClass, "bi-trash-fill" }
        };

        var options = new DialogOptions
        {
            MaxWidth = MaxWidth.Small,
            FullWidth = true,
            CloseButton = true
        };

        var dialog = await DialogService.ShowAsync<ConfirmationModal>(
            "Delete Filtered Messages",
            parameters,
            options);

        var result = await dialog.Result;

        if (!result.Canceled)
        {
            await ExecutePurgeOperation(true);
        }
    }

    private async Task HandleExportFilteredMessages()
    {
        try
        {
            // Apply filters to get the messages to export
            var filterService = new Application.Services.MessageFilterService();
            var filteredMessages = filterService.ApplyFilters(messages, messageFilters).ToList();
            
            if (!filteredMessages.Any())
            {
                operationErrorMessage = "No messages match the current filters.";
                await Task.Delay(3000);
                operationErrorMessage = string.Empty;
                StateHasChanged();
                return;
            }

            // Convert to JSON
            var options = new JsonSerializerOptions
            {
                WriteIndented = true,
                PropertyNamingPolicy = JsonNamingPolicy.CamelCase
            };
            var json = JsonSerializer.Serialize(filteredMessages, options);
            
            // Generate filename
            var timestamp = DateTime.Now.ToString("yyyyMMdd_HHmmss");
            var messageTypeDisplay = selectedMessageType.ToLower();
            var filename = $"{selectedEntity.Replace("/", "_")}_{messageTypeDisplay}_messages_{timestamp}.json";
            
            // Export file using the platform-specific service
            var success = await FileExportService.ExportToFileAsync(filename, json);
            
            if (success)
            {
                successMessage = $"Successfully exported {filteredMessages.Count} message(s) to {filename}.";
            }
            else
            {
                operationErrorMessage = "Failed to export messages. Please try again.";
            }
            
            await Task.Delay(3000);
            successMessage = string.Empty;
            operationErrorMessage = string.Empty;
            StateHasChanged();
        }
        catch (Exception ex)
        {
            operationErrorMessage = $"Error exporting messages: {ex.Message}";
            await Task.Delay(5000);
            operationErrorMessage = string.Empty;
            StateHasChanged();
        }
    }

    private async Task HandleExportSingleMessage(MessageInfo message)
    {
        try
        {
            // Convert to JSON
            var options = new JsonSerializerOptions
            {
                WriteIndented = true,
                PropertyNamingPolicy = JsonNamingPolicy.CamelCase
            };
            var json = JsonSerializer.Serialize(message, options);
            
            // Generate filename using message ID
            var timestamp = DateTime.Now.ToString("yyyyMMdd_HHmmss");
            var messageTypeDisplay = selectedMessageType.ToLower();
            var sanitizedMessageId = message.MessageId.Length > 20 
                ? message.MessageId.Substring(0, 20) 
                : message.MessageId;
            var filename = $"{selectedEntity.Replace("/", "_")}_{messageTypeDisplay}_message_{sanitizedMessageId}_{timestamp}.json";
            
            // Export file using the platform-specific service
            var success = await FileExportService.ExportToFileAsync(filename, json);
            
            if (success)
            {
                successMessage = $"Successfully exported message to {filename}.";
            }
            else
            {
                operationErrorMessage = "Failed to export message. Please try again.";
            }
            
            await Task.Delay(3000);
            successMessage = string.Empty;
            operationErrorMessage = string.Empty;
            StateHasChanged();
        }
        catch (Exception ex)
        {
            operationErrorMessage = $"Error exporting message: {ex.Message}";
            await Task.Delay(5000);
            operationErrorMessage = string.Empty;
            StateHasChanged();
        }
    }

    private async Task HandleToggleQueueStatus(string queueName)
    {
        operationErrorMessage = string.Empty;
        successMessage = string.Empty;

        try
        {
            // Find the queue to toggle its status
            var queue = queues.FirstOrDefault(q => q.Name == queueName);
            if (queue == null) return;

            bool newStatus = queue.Status != "Active";
            bool success = await ServiceBusService.SetQueueStatusAsync(queueName, newStatus);

            if (success)
            {
                // Refresh the queue info to get the updated status
                var updatedQueue = await ServiceBusService.GetQueueInfoAsync(queueName);
                if (updatedQueue != null)
                {
                    var index = queues.FindIndex(q => q.Name == queueName);
                    if (index >= 0)
                    {
                        queues[index] = updatedQueue;
                    }
                    
                    // Update selected queue info if this is the selected queue
                    if (selectedEntityType == "queue" && selectedEntityName == queueName)
                    {
                        selectedQueueInfo = updatedQueue;
                    }
                }

                successMessage = $"Queue '{queueName}' has been {(newStatus ? "enabled" : "disabled")}.";
                await Task.Delay(3000);
                successMessage = string.Empty;
            }
            else
            {
                operationErrorMessage = $"Failed to {(newStatus ? "enable" : "disable")} queue '{queueName}'.";
                await Task.Delay(5000);
                operationErrorMessage = string.Empty;
            }
        }
        catch (Exception ex)
        {
            operationErrorMessage = $"Error: {ex.Message}";
            await Task.Delay(5000);
            operationErrorMessage = string.Empty;
        }
    }

    private async Task HandleToggleTopicStatus(string topicName)
    {
        operationErrorMessage = string.Empty;
        successMessage = string.Empty;

        try
        {
            // Find the topic to toggle its status
            var topic = topics.FirstOrDefault(t => t.Name == topicName);
            if (topic == null) return;

            bool newStatus = topic.Status != "Active";
            bool success = await ServiceBusService.SetTopicStatusAsync(topicName, newStatus);

            if (success)
            {
                // Refresh the topic info to get the updated status
                var updatedTopic = await ServiceBusService.GetTopicInfoAsync(topicName);
                if (updatedTopic != null)
                {
                    var index = topics.FindIndex(t => t.Name == topicName);
                    if (index >= 0)
                    {
                        topics[index] = updatedTopic;
                    }
                    
                    // Update selected topic info if this is the selected topic
                    if (selectedEntityType == "topic" && selectedEntityName == topicName)
                    {
                        selectedTopicInfo = updatedTopic;
                    }
                }

                successMessage = $"Topic '{topicName}' has been {(newStatus ? "enabled" : "disabled")}.";
                await Task.Delay(3000);
                successMessage = string.Empty;
            }
            else
            {
                operationErrorMessage = $"Failed to {(newStatus ? "enable" : "disable")} topic '{topicName}'.";
                await Task.Delay(5000);
                operationErrorMessage = string.Empty;
            }
        }
        catch (Exception ex)
        {
            operationErrorMessage = $"Error: {ex.Message}";
            await Task.Delay(5000);
            operationErrorMessage = string.Empty;
        }
    }

    private async Task HandleToggleSubscriptionStatus((string TopicName, string SubscriptionName) args)
    {
        operationErrorMessage = string.Empty;
        successMessage = string.Empty;

        try
        {
            // Find the subscription to toggle its status
            SubscriptionInfo? subscription = null;
            if (topicSubscriptions.ContainsKey(args.TopicName))
            {
                subscription = topicSubscriptions[args.TopicName].FirstOrDefault(s => s.Name == args.SubscriptionName);
            }
            
            if (subscription == null) return;

            bool newStatus = subscription.Status != "Active";
            bool success = await ServiceBusService.SetSubscriptionStatusAsync(args.TopicName, args.SubscriptionName, newStatus);

            if (success)
            {
                // Refresh the subscription info to get the updated status
                var updatedSubscription = await ServiceBusService.GetSubscriptionInfoAsync(args.TopicName, args.SubscriptionName);
                if (updatedSubscription != null && topicSubscriptions.ContainsKey(args.TopicName))
                {
                    var index = topicSubscriptions[args.TopicName].FindIndex(s => s.Name == args.SubscriptionName);
                    if (index >= 0)
                    {
                        topicSubscriptions[args.TopicName][index] = updatedSubscription;
                    }
                    
                    // Update selected subscription info if this is the selected subscription
                    if (selectedEntityType == "subscription" && selectedEntityName == $"{args.TopicName}/{args.SubscriptionName}")
                    {
                        selectedSubscriptionInfo = updatedSubscription;
                    }
                }

                successMessage = $"Subscription '{args.SubscriptionName}' has been {(newStatus ? "enabled" : "disabled")}.";
                await Task.Delay(3000);
                successMessage = string.Empty;
            }
            else
            {
                operationErrorMessage = $"Failed to {(newStatus ? "enable" : "disable")} subscription '{args.SubscriptionName}'.";
                await Task.Delay(5000);
                operationErrorMessage = string.Empty;
            }
        }
        catch (Exception ex)
        {
            operationErrorMessage = $"Error: {ex.Message}";
            await Task.Delay(5000);
            operationErrorMessage = string.Empty;
        }
    }

    private async Task RefreshEntityCounts()
    {
        // Refresh queue or topic counts after message operations
        if (!string.IsNullOrEmpty(selectedEntity) && string.IsNullOrEmpty(selectedSubscriptionName))
        {
            // It's a queue
            var updatedQueue = await ServiceBusService.GetQueueInfoAsync(selectedEntity);
            if (updatedQueue != null)
            {
                var index = queues.FindIndex(q => q.Name == selectedEntity);
                if (index >= 0)
                {
                    queues[index] = updatedQueue;
                }
                
                // Update selected queue info in details panel
                if (selectedEntityType == "queue" && selectedEntityName == selectedEntity)
                {
                    selectedQueueInfo = updatedQueue;
                }
            }
        }
        else if (!string.IsNullOrEmpty(selectedSubscriptionName))
        {
            // It's a subscription
            var updatedSubscription = await ServiceBusService.GetSubscriptionInfoAsync(selectedTopic, selectedSubscriptionName);
            if (updatedSubscription != null && topicSubscriptions.ContainsKey(selectedTopic))
            {
                var index = topicSubscriptions[selectedTopic].FindIndex(s => s.Name == selectedSubscriptionName);
                if (index >= 0)
                {
                    topicSubscriptions[selectedTopic][index] = updatedSubscription;
                }
                
                // Update selected subscription info in details panel
                if (selectedEntityType == "subscription" && selectedEntityName == $"{selectedTopic}/{selectedSubscriptionName}")
                {
                    selectedSubscriptionInfo = updatedSubscription;
                }
            }
        }
    }

    private string GetPageTitle()
    {
        if (ServiceBusService.IsConnected)
        {
            var namespaceName = ServiceBusService.GetNamespace();
            return !string.IsNullOrEmpty(namespaceName) ? namespaceName : "Azure Service Bus Inspector";
        }
        return "Azure Service Bus Inspector";
    }
}

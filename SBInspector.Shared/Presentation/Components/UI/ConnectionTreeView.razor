@using SBInspector.Shared.Core.Domain
@using SBInspector.Shared.Core.Interfaces
@using SBInspector.Shared.Application.Services
@using MudBlazor
@inject IStorageService StorageService
@inject IServiceBusService ServiceBusService
@inject ConnectionStateService ConnectionState
@inject ConnectionStringEncryptionService EncryptionService
@implements IDisposable

<MudPaper Class="pa-2 mud-elevation-2">
    <MudText Typo="Typo.h6" Class="mb-2"><MudIcon Icon="@Icons.Material.Filled.ElectricalServices" /> Connections</MudText>
    @if (isLoading)
    {
        <MudStack AlignItems="AlignItems.Center" Class="py-2">
            <MudProgressCircular Color="Color.Primary" Size="Size.Small" />
        </MudStack>
    }
    else if (savedConnections.Any())
    {
        <MudList T=SavedConnection Dense="true">
            @foreach (var connection in savedConnections)
            {
                <MudListItem Class="@((IsConnected(connection) ? "mud-selected" : ""))" Style="cursor:pointer;" @onclick="() => HandleConnectionClick(connection)" Title="@(IsConnected(connection) ? "Click to disconnect" : "Click to connect")">
                    <MudIcon Icon="@(IsConnected(connection) ? Icons.Material.Filled.ElectricalServices : Icons.Material.Outlined.ElectricalServices)" Color="@(IsConnected(connection) ? Color.Primary : Color.Default)" />
                    <MudText Class="ml-2">@connection.Name</MudText>
                    @if (IsConnected(connection))
                    {
                        <MudChip Color="Color.Success" Size="Size.Small" Class="ml-2">Connected</MudChip>
                    }
                </MudListItem>
            }
        </MudList>
    }
    else
    {
        <MudText Typo="Typo.caption" Color="Color.Secondary">No saved connections</MudText>
    }
</MudPaper>

@code {
    [Parameter]
    public EventCallback<SavedConnection> OnConnect { get; set; }

    [Parameter]
    public EventCallback OnDisconnect { get; set; }

    private List<SavedConnection> savedConnections = new();
    private bool isLoading = false;

    protected override async Task OnInitializedAsync()
    {
        await LoadConnectionsAsync();
        ConnectionState.OnChange += HandleConnectionStateChanged;
        ConnectionState.OnConnectionsChanged += HandleConnectionsListChanged;
    }

    private async Task LoadConnectionsAsync()
    {
        isLoading = true;
        try
        {
            savedConnections = await StorageService.GetSavedConnectionsAsync();
            savedConnections = savedConnections
            .OrderByDescending(c => c.LastUsedAt ?? DateTime.MinValue)
            .ThenBy(c => c.Name)
            .ToList();
        }
        finally
        {
            isLoading = false;
        }
    }

    public async Task RefreshConnectionsAsync()
    {
        await LoadConnectionsAsync();
        StateHasChanged();
    }

    private void HandleConnectionStateChanged()
    {
        StateHasChanged();
    }

    private async void HandleConnectionsListChanged()
    {
        await RefreshConnectionsAsync();
    }

    private bool IsConnected(SavedConnection connection)
    {
        if (!ServiceBusService.IsConnected || string.IsNullOrEmpty(ConnectionState.CurrentConnectionString))
        {
            return false;
        }
        var connectionString = connection.IsEncrypted
        ? EncryptionService.Decrypt(connection.ConnectionString)
        : connection.ConnectionString;
        return connectionString == ConnectionState.CurrentConnectionString;
    }

    private async Task HandleConnectionClick(SavedConnection connection)
    {
        if (IsConnected(connection))
        {
            await OnDisconnect.InvokeAsync();
        }
        else
        {
            await OnConnect.InvokeAsync(connection);
        }
    }

    public void Dispose()
    {
        ConnectionState.OnChange -= HandleConnectionStateChanged;
        ConnectionState.OnConnectionsChanged -= HandleConnectionsListChanged;
    }
}
